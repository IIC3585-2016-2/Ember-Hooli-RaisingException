<!DOCTYPE html>
<html>

<head>
    <title>Ember</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="./assets/style.css">
</head>

<body>
    <textarea id="source" style="display:none;">

class: center, middle, inverse

.center[![Logo](./assets/images/ember-light.png)]

### Jaime Castro
### Vicente Dragicevic
### Fernando Florenzano
### Matías Juneman

---

# Outline

1. Introducción
2. Software Stack
3. Conceptos Básicos
4. Futuro

---
class: center, middle, inverse

# Introducción

---
# ¿Ember?

* Web framework en JavaScript
* Model-view-viewmodel (MVVM)
* Single-page apps

---
# Filosofía y Diseño

* Convention over Configuration (CoC)
* Don't Repeat Yourself (DRY)

Es a veces descrito como "highly opinionated" pero construido para ser muy flexible.

---
class: center, middle, inverse

# Software Stack

---
# Software Stack

### Ember-CLI

Herramientas para la terminal.

### Ember-Data

Librería de persistencia de datos.
Mapea modelos en el cliente a datos en el servidor.

### Ember-Inspector

Extensiones para Firefox/Chrome para debugueo.

---
# Software Stack

### Fastboot

Permite montar aplicaciones hechas en Ember sobre Node.js

### Liquid Fire

Provee soporte de animaciones:
  * Transiciones animadas entre diferentes rutas/modelos.

---
class: center, middle, inverse

# Conceptos Básicos

---
# Rutas

```bash
ember generate route about
ember generate route favorites
```

Estos comandos crean un archivo para cada ruta, un template, un archivo de tests unitarios. 
Luego en `app/router.js`

```bash
Router.map(() => {
  this.route('about');
  this.route('favorites', { path: '/favs' });
});
```

---
# Rutas

Podemos anidar rutas fácilmente con un callback:

```javascript
Router.map(() => {
  this.route('about', () => {
    this.route('faq');
  });
});
```

O podemos generarla con un comando:

'''bash
ember generate route about/faqs
'''

---
# Rutas

Para rutas con parámetros:

```javascript
Router.map(() => {
  this.route('about', () => {
    this.route('faq', { path: '/faq/:faq_id'});
  });
});
```

Es importante notar que se debe usar el formato `modelo_id`, para que la ruta pueda cargar el modelo correcto.

---
# Rutas

También podemos crear una ruta que haga *match* con varios URLs.

Un uso común es cuando no existe la página que se intenta acceder:

'''javascript
Router.map(() => {
  this.route('404', { path: '/*wildcard' });
});
'''
---
# Models

---
# Templates

Los templates definen **cómo se ve** la interfaz de usuario. Ember utiliza la librería **Handlebars**.

* Contienen HTML estático

* Permiten contenido dinámico dentro de expresiones {{}}

* Data-Binding: al cambiar el valor de una expresión, se actualiza su representación visual automáticamente

* Tienen un **contexto**, de donde las expresiones leen sus propiedades:
	* Usualmente es otro componente
	* Para templates rendereados por rutas (`application.hbs`), es el controlador

---
# Templates: Ejemplos

## Template rendereado por ruta

El controlador de la aplicación: app/controllers/application.js

```javascript
import Ember from 'ember';

export default Ember.Controller.extend({
  firstName: 'Jaime',
  lastName: 'Castro'
});
```

Template de la aplicación: app/templates/application.hbs
```hbs
Hello, <strong>{{firstName}} {{lastName}}</strong>!
```


---
# Templates

---
# Templates: Helpers

Los Helpers permiten añadir un poco de lógica.

Ember viene con algunos helpers, pero también permite crearlos:

```javascript
export function sum(params) {
	return params.reduce((a, b) => a + b);
};
export default Ember.Helper.helper(sum);
```

Luego lo usamos en un template:

```hbs
<p>Total: {{sum 1 2 3}}</p>
```
---
# Componentes

Controlan el **comportamiento** de la interfaz de usuario.

Están formados por:
* Un template
* Código JavaScript que define su comportamiento

---
# Componentes

```bash
> ember generate component blog-post
```

Luego definimos su template:
```hbs
<article class="blog-post">
  <h1>{{title}}</h1>
  <p>{{yield}}</p>
  <p>Edit title: {{input type="text" value=title}}</p>
</article>
```

---
# Componentes

Ahora podemos usarlo!
```hbs
{{#each model as |post|}}
  {{#blog-post title=post.title}}
    {{post.body}}
  {{/blog-post}}
{{/each}}
```

---
# Componentes

Holi
---
# Servicios

* Singletons que viven durante todo el ciclo de vida de la app.

* Utilizados en features que comparten estado o conexiones persistentes.

* Geolocation, sesiones, WebSockets, Logging...

---
# Servicios

```bash
ember generate service shopping-cart
```

Deben extender la clase `Ember.Service`

```javascript
export default Ember.Service.extend({
  items: null,
  init() {
    this._super(...arguments);
    this.set('items', []);
  },
  add(item) {
    this.get('items').pushObject(item);
  },
});
```

---
# Servicios

Debemos "inyectar" el servicio en un componente/otro servicio:

```javascript
export default Ember.Component.extend({
  shoppingCart: Ember.inject.service()
});
```

Las propiedades inyectadas son cargadas de forma **lazy**, por lo que se acceden con la función `get`.

---
# Servicios

Podemos acceder al servicio dentro del template del componente:

```hbs
<ul>
  {{#each cart.items as |item|}}
    <li>
      {{item.name}}
      <button {{action "remove" item}}>Remove</button>
    </li>
  {{/each}}
</ul>
```
---
class: center, middle, inverse

# Futuro

---
# Futuro

* Glimmer 2: un nuevo motor de renderizado para Ember
* Engines: Permiten componer una aplicación a partir de múltiples otras. Por ahora hay soporte experimental.

---
class: center, middle, inverse

# That's all folks!


    </textarea>
    <script src="./assets/remark.min.js">
    </script>
    <script>
        var slideshow = remark.create({
            ratio: '16:9',
            highlightStyle: 'monokai',
            highlightLines: true
        });
    </script>
</body>

</html>
